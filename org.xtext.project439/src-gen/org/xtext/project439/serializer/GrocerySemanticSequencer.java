/*
 * generated by Xtext 2.15.0
 */
package org.xtext.project439.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.project439.grocery.Backroom;
import org.xtext.project439.grocery.Customer;
import org.xtext.project439.grocery.Delivery;
import org.xtext.project439.grocery.Driver;
import org.xtext.project439.grocery.Employee;
import org.xtext.project439.grocery.Grocery;
import org.xtext.project439.grocery.GroceryPackage;
import org.xtext.project439.grocery.NonFoodItem;
import org.xtext.project439.grocery.PerishableItem;
import org.xtext.project439.grocery.Produce;
import org.xtext.project439.grocery.Sale;
import org.xtext.project439.grocery.Shelf;
import org.xtext.project439.grocery.StockMovement;
import org.xtext.project439.grocery.Store;
import org.xtext.project439.grocery.Supplier;
import org.xtext.project439.grocery.Vehicle;
import org.xtext.project439.grocery.Warehouse;
import org.xtext.project439.services.GroceryGrammarAccess;

@SuppressWarnings("all")
public class GrocerySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GroceryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GroceryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GroceryPackage.BACKROOM:
				sequence_Backroom(context, (Backroom) semanticObject); 
				return; 
			case GroceryPackage.CUSTOMER:
				sequence_Customer(context, (Customer) semanticObject); 
				return; 
			case GroceryPackage.DELIVERY:
				sequence_Delivery(context, (Delivery) semanticObject); 
				return; 
			case GroceryPackage.DRIVER:
				sequence_Driver(context, (Driver) semanticObject); 
				return; 
			case GroceryPackage.EMPLOYEE:
				sequence_Employee(context, (Employee) semanticObject); 
				return; 
			case GroceryPackage.GROCERY:
				sequence_Grocery(context, (Grocery) semanticObject); 
				return; 
			case GroceryPackage.NON_FOOD_ITEM:
				sequence_NonFoodItem(context, (NonFoodItem) semanticObject); 
				return; 
			case GroceryPackage.PERISHABLE_ITEM:
				sequence_PerishableItem(context, (PerishableItem) semanticObject); 
				return; 
			case GroceryPackage.PRODUCE:
				sequence_Produce(context, (Produce) semanticObject); 
				return; 
			case GroceryPackage.SALE:
				sequence_Sale(context, (Sale) semanticObject); 
				return; 
			case GroceryPackage.SHELF:
				sequence_Shelf(context, (Shelf) semanticObject); 
				return; 
			case GroceryPackage.STOCK_MOVEMENT:
				sequence_StockMovement(context, (StockMovement) semanticObject); 
				return; 
			case GroceryPackage.STORE:
				sequence_Store(context, (Store) semanticObject); 
				return; 
			case GroceryPackage.SUPPLIER:
				sequence_Supplier(context, (Supplier) semanticObject); 
				return; 
			case GroceryPackage.VEHICLE:
				sequence_Vehicle(context, (Vehicle) semanticObject); 
				return; 
			case GroceryPackage.WAREHOUSE:
				sequence_Warehouse(context, (Warehouse) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractElement returns Backroom
	 *     StoreElements returns Backroom
	 *     Backroom returns Backroom
	 *
	 * Constraint:
	 *     (name=ID items+=[Item|ID]*)
	 */
	protected void sequence_Backroom(ISerializationContext context, Backroom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Customer
	 *     MovementElement returns Customer
	 *     Person returns Customer
	 *     Customer returns Customer
	 *
	 * Constraint:
	 *     (name=ID customerName=STRING sale+=[Sale|ID]*)
	 */
	protected void sequence_Customer(ISerializationContext context, Customer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Delivery
	 *     Movement returns Delivery
	 *     VehicleElements returns Delivery
	 *     Delivery returns Delivery
	 *
	 * Constraint:
	 *     (name=ID fromWarehouse=[Warehouse|ID] toStore=[Store|ID] items+=[Item|ID]*)
	 */
	protected void sequence_Delivery(ISerializationContext context, Delivery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Driver
	 *     MovementElement returns Driver
	 *     Person returns Driver
	 *     Driver returns Driver
	 *
	 * Constraint:
	 *     (name=ID driverName=STRING vehicle+=[Vehicle|ID] delivery+=[Delivery|ID]*)
	 */
	protected void sequence_Driver(ISerializationContext context, Driver semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Employee
	 *     MovementElement returns Employee
	 *     Person returns Employee
	 *     Employee returns Employee
	 *
	 * Constraint:
	 *     (name=ID employeeName=STRING stockMovement+=[StockMovement|ID]*)
	 */
	protected void sequence_Employee(ISerializationContext context, Employee semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Grocery returns Grocery
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 */
	protected void sequence_Grocery(ISerializationContext context, Grocery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns NonFoodItem
	 *     Item returns NonFoodItem
	 *     VehicleElements returns NonFoodItem
	 *     NonFoodItem returns NonFoodItem
	 *
	 * Constraint:
	 *     (name=ID price=DECIMAL quantity=INT)
	 */
	protected void sequence_NonFoodItem(ISerializationContext context, NonFoodItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__PRICE));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonFoodItemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNonFoodItemAccess().getPriceDECIMALParserRuleCall_5_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getNonFoodItemAccess().getQuantityINTTerminalRuleCall_8_0(), semanticObject.getQuantity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns PerishableItem
	 *     Item returns PerishableItem
	 *     FoodItem returns PerishableItem
	 *     VehicleElements returns PerishableItem
	 *     PerishableItem returns PerishableItem
	 *
	 * Constraint:
	 *     (name=ID price=DECIMAL quantity=INT experationDate=DATE)
	 */
	protected void sequence_PerishableItem(ISerializationContext context, PerishableItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__PRICE));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.PERISHABLE_ITEM__EXPERATION_DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.PERISHABLE_ITEM__EXPERATION_DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPerishableItemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPerishableItemAccess().getPriceDECIMALParserRuleCall_5_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getPerishableItemAccess().getQuantityINTTerminalRuleCall_8_0(), semanticObject.getQuantity());
		feeder.accept(grammarAccess.getPerishableItemAccess().getExperationDateDATEParserRuleCall_11_0(), semanticObject.getExperationDate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Produce
	 *     Item returns Produce
	 *     FoodItem returns Produce
	 *     VehicleElements returns Produce
	 *     Produce returns Produce
	 *
	 * Constraint:
	 *     (name=ID price=DECIMAL quantity=INT quality=qualityLevel)
	 */
	protected void sequence_Produce(ISerializationContext context, Produce semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__PRICE));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.PRODUCE__QUALITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.PRODUCE__QUALITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProduceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProduceAccess().getPriceDECIMALParserRuleCall_5_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getProduceAccess().getQuantityINTTerminalRuleCall_8_0(), semanticObject.getQuantity());
		feeder.accept(grammarAccess.getProduceAccess().getQualityQualityLevelEnumRuleCall_11_0(), semanticObject.getQuality());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Sale
	 *     Movement returns Sale
	 *     Sale returns Sale
	 *
	 * Constraint:
	 *     (name=ID fromShelf=[Shelf|ID] items+=[Item|ID]*)
	 */
	protected void sequence_Sale(ISerializationContext context, Sale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Shelf
	 *     StoreElements returns Shelf
	 *     Shelf returns Shelf
	 *
	 * Constraint:
	 *     (name=ID items+=[Item|ID]*)
	 */
	protected void sequence_Shelf(ISerializationContext context, Shelf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns StockMovement
	 *     Movement returns StockMovement
	 *     StockMovement returns StockMovement
	 *
	 * Constraint:
	 *     (name=ID fromBackroom=[Backroom|ID] toShelf=[Shelf|ID] items+=[Item|ID]*)
	 */
	protected void sequence_StockMovement(ISerializationContext context, StockMovement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Store
	 *     Building returns Store
	 *     Store returns Store
	 *
	 * Constraint:
	 *     (name=ID elements+=[StoreElements|ID]*)
	 */
	protected void sequence_Store(ISerializationContext context, Store semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Supplier
	 *     MovementElement returns Supplier
	 *     Supplier returns Supplier
	 *
	 * Constraint:
	 *     (name=ID items+=[Item|ID]*)
	 */
	protected void sequence_Supplier(ISerializationContext context, Supplier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Vehicle
	 *     MovementElement returns Vehicle
	 *     Vehicle returns Vehicle
	 *
	 * Constraint:
	 *     (name=ID plateNumber=STRING delivery+=[Delivery|ID]*)
	 */
	protected void sequence_Vehicle(ISerializationContext context, Vehicle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Warehouse
	 *     Building returns Warehouse
	 *     Warehouse returns Warehouse
	 *
	 * Constraint:
	 *     (name=ID address=ADDRESS supplier=[Supplier|ID])
	 */
	protected void sequence_Warehouse(ISerializationContext context, Warehouse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ABSTRACT_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.WAREHOUSE__ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.WAREHOUSE__ADDRESS));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.WAREHOUSE__SUPPLIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.WAREHOUSE__SUPPLIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWarehouseAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWarehouseAccess().getAddressADDRESSParserRuleCall_5_0(), semanticObject.getAddress());
		feeder.accept(grammarAccess.getWarehouseAccess().getSupplierSupplierIDTerminalRuleCall_8_0_1(), semanticObject.eGet(GroceryPackage.Literals.WAREHOUSE__SUPPLIER, false));
		feeder.finish();
	}
	
	
}
