/*
 * generated by Xtext 2.15.0
 */
package org.xtext.project439.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.project439.grocery.Backroom;
import org.xtext.project439.grocery.Customer;
import org.xtext.project439.grocery.Delivery;
import org.xtext.project439.grocery.Driver;
import org.xtext.project439.grocery.Employee;
import org.xtext.project439.grocery.Grocery;
import org.xtext.project439.grocery.GroceryPackage;
import org.xtext.project439.grocery.NonFoodItem;
import org.xtext.project439.grocery.NonPerishableItem;
import org.xtext.project439.grocery.PerishableItem;
import org.xtext.project439.grocery.Sale;
import org.xtext.project439.grocery.Shelf;
import org.xtext.project439.grocery.StockMovement;
import org.xtext.project439.grocery.Store;
import org.xtext.project439.grocery.Vehicle;
import org.xtext.project439.grocery.Warehouse;
import org.xtext.project439.services.GroceryGrammarAccess;

@SuppressWarnings("all")
public class GrocerySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GroceryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GroceryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GroceryPackage.BACKROOM:
				sequence_Backroom(context, (Backroom) semanticObject); 
				return; 
			case GroceryPackage.CUSTOMER:
				sequence_Customer(context, (Customer) semanticObject); 
				return; 
			case GroceryPackage.DELIVERY:
				sequence_Delivery(context, (Delivery) semanticObject); 
				return; 
			case GroceryPackage.DRIVER:
				sequence_Driver(context, (Driver) semanticObject); 
				return; 
			case GroceryPackage.EMPLOYEE:
				sequence_Employee(context, (Employee) semanticObject); 
				return; 
			case GroceryPackage.GROCERY:
				sequence_Grocery(context, (Grocery) semanticObject); 
				return; 
			case GroceryPackage.NON_FOOD_ITEM:
				sequence_NonFoodItem(context, (NonFoodItem) semanticObject); 
				return; 
			case GroceryPackage.NON_PERISHABLE_ITEM:
				sequence_NonPerishableItem(context, (NonPerishableItem) semanticObject); 
				return; 
			case GroceryPackage.PERISHABLE_ITEM:
				sequence_PerishableItem(context, (PerishableItem) semanticObject); 
				return; 
			case GroceryPackage.SALE:
				sequence_Sale(context, (Sale) semanticObject); 
				return; 
			case GroceryPackage.SHELF:
				sequence_Shelf(context, (Shelf) semanticObject); 
				return; 
			case GroceryPackage.STOCK_MOVEMENT:
				sequence_StockMovement(context, (StockMovement) semanticObject); 
				return; 
			case GroceryPackage.STORE:
				sequence_Store(context, (Store) semanticObject); 
				return; 
			case GroceryPackage.VEHICLE:
				sequence_Vehicle(context, (Vehicle) semanticObject); 
				return; 
			case GroceryPackage.WAREHOUSE:
				sequence_Warehouse(context, (Warehouse) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     StoreElements returns Backroom
	 *     Backroom returns Backroom
	 *
	 * Constraint:
	 *     (name=ID items+=[Item|ID]*)
	 */
	protected void sequence_Backroom(ISerializationContext context, Backroom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MovementElement returns Customer
	 *     Person returns Customer
	 *     Customer returns Customer
	 *
	 * Constraint:
	 *     (name=ID customerName=STRING sale+=[Sale|ID]*)
	 */
	protected void sequence_Customer(ISerializationContext context, Customer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns Delivery
	 *     Delivery returns Delivery
	 *
	 * Constraint:
	 *     (name=ID fromWarehouse=[Warehouse|ID] toStore=[Store|ID] items+=[Item|ID]*)
	 */
	protected void sequence_Delivery(ISerializationContext context, Delivery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MovementElement returns Driver
	 *     Person returns Driver
	 *     Driver returns Driver
	 *
	 * Constraint:
	 *     (name=ID driverName=STRING vehicle+=[Vehicle|ID]*)
	 */
	protected void sequence_Driver(ISerializationContext context, Driver semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MovementElement returns Employee
	 *     Person returns Employee
	 *     Employee returns Employee
	 *
	 * Constraint:
	 *     (name=ID employeeName=STRING stockMovement+=[StockMovement|ID]*)
	 */
	protected void sequence_Employee(ISerializationContext context, Employee semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Grocery returns Grocery
	 *
	 * Constraint:
	 *     (
	 *         (elements+=Building+ ((elements+=Movement+ elements+=StoreElements+) | elements+=StoreElements+)) | 
	 *         (
	 *             ((elements+=Building+ elements+=MovementElement+) | elements+=MovementElement+) 
	 *             ((elements+=Movement+ elements+=StoreElements+) | elements+=StoreElements+)
	 *         ) | 
	 *         (
	 *             (
	 *                 (elements+=Building+ ((elements+=MovementElement+ elements+=Movement+) | elements+=Movement+)) | 
	 *                 (elements+=MovementElement+ elements+=Movement+) | 
	 *                 elements+=Movement+
	 *             )? 
	 *             elements+=Item+ 
	 *             elements+=StoreElements+
	 *         ) | 
	 *         (elements+=Movement+ elements+=StoreElements+) | 
	 *         elements+=StoreElements+
	 *     )?
	 */
	protected void sequence_Grocery(ISerializationContext context, Grocery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Item returns NonFoodItem
	 *     NonFoodItem returns NonFoodItem
	 *
	 * Constraint:
	 *     (name=ID price=DECIMAL quantity=INT)
	 */
	protected void sequence_NonFoodItem(ISerializationContext context, NonFoodItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__PRICE));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonFoodItemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNonFoodItemAccess().getPriceDECIMALParserRuleCall_5_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getNonFoodItemAccess().getQuantityINTTerminalRuleCall_8_0(), semanticObject.getQuantity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Item returns NonPerishableItem
	 *     FoodItem returns NonPerishableItem
	 *     NonPerishableItem returns NonPerishableItem
	 *
	 * Constraint:
	 *     (name=ID price=DECIMAL quantity=INT)
	 */
	protected void sequence_NonPerishableItem(ISerializationContext context, NonPerishableItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__PRICE));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNonPerishableItemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNonPerishableItemAccess().getPriceDECIMALParserRuleCall_5_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getNonPerishableItemAccess().getQuantityINTTerminalRuleCall_8_0(), semanticObject.getQuantity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Item returns PerishableItem
	 *     FoodItem returns PerishableItem
	 *     PerishableItem returns PerishableItem
	 *
	 * Constraint:
	 *     (name=ID price=DECIMAL quantity=INT experationDate=DATE)
	 */
	protected void sequence_PerishableItem(ISerializationContext context, PerishableItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__NAME));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__PRICE));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.ITEM__QUANTITY));
			if (transientValues.isValueTransient(semanticObject, GroceryPackage.Literals.PERISHABLE_ITEM__EXPERATION_DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GroceryPackage.Literals.PERISHABLE_ITEM__EXPERATION_DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPerishableItemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPerishableItemAccess().getPriceDECIMALParserRuleCall_5_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getPerishableItemAccess().getQuantityINTTerminalRuleCall_8_0(), semanticObject.getQuantity());
		feeder.accept(grammarAccess.getPerishableItemAccess().getExperationDateDATEParserRuleCall_11_0(), semanticObject.getExperationDate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns Sale
	 *     Sale returns Sale
	 *
	 * Constraint:
	 *     (name=ID fromShelf=[Shelf|ID] items+=[Item|ID]*)
	 */
	protected void sequence_Sale(ISerializationContext context, Sale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StoreElements returns Shelf
	 *     Shelf returns Shelf
	 *
	 * Constraint:
	 *     (name=ID items+=[Item|ID]*)
	 */
	protected void sequence_Shelf(ISerializationContext context, Shelf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns StockMovement
	 *     StockMovement returns StockMovement
	 *
	 * Constraint:
	 *     (name=ID fromBackroom=[Backroom|ID] toShelf=[Shelf|ID] items+=[Item|ID]*)
	 */
	protected void sequence_StockMovement(ISerializationContext context, StockMovement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Building returns Store
	 *     Store returns Store
	 *
	 * Constraint:
	 *     (name=ID elements+=[StoreElements|ID]*)
	 */
	protected void sequence_Store(ISerializationContext context, Store semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MovementElement returns Vehicle
	 *     Vehicle returns Vehicle
	 *
	 * Constraint:
	 *     (name=ID plateNumber=STRING items+=[Item|ID]*)
	 */
	protected void sequence_Vehicle(ISerializationContext context, Vehicle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Building returns Warehouse
	 *     Warehouse returns Warehouse
	 *
	 * Constraint:
	 *     (name=ID address=ADDRESS items+=[Item|ID]*)
	 */
	protected void sequence_Warehouse(ISerializationContext context, Warehouse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
